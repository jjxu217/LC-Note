# 921/856. Minimum Add to Make Parentheses Valid

Given a string `S` of `'('` and `')'` parentheses, we add the minimum number of parentheses \( `'('` or `')'`, and in any positions \) so that the resulting parentheses string is valid.

Formally, a parentheses string is valid if and only if:

* It is the empty string, or
* It can be written as `AB` \(`A` concatenated with `B`\), where `A` and `B` are valid strings, or
* It can be written as `(A)`, where `A` is a valid string.

Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.

**Example 1:**

```text
Input: "())"
Output: 1
```

**Example 2:**

```text
Input: "((("
Output: 3
```

**Example 3:**

```text
Input: "()"
Output: 0
```

**Example 4:**

```text
Input: "()))(("
Output: 4
```

```python
class Solution:
    def minAddToMakeValid(self, S: str) -> int:
        stack = []
        for s in S:
            if s == '(':
                stack.append(0)
            else:
                if not stack or stack[-1] == 1:
                    stack.append(1)
                else:
                    stack.pop()
        return len(stack)
    
    def minAddToMakeValid(self, S: str) -> int:
        res = bal = 0
        for s in S:
            bal += 1 if s == '(' else -1
            # It is guaranteed bal >= -1
            if bal == -1:
                res += 1
                bal = 0
        return res + bal
```

## 856. Score of Parentheses

Given a balanced parentheses string `S`, compute the score of the string based on the following rule:

* `()` has score 1
* `AB` has score `A + B`, where A and B are balanced parentheses strings.
* `(A)` has score `2 * A`, where A is a balanced parentheses string.

**Example 1:**

```text
Input: "()"
Output: 1
```

**Example 2:**

```text
Input: "(())"
Output: 2
```

**Example 3:**

```text
Input: "()()"
Output: 2
```

**Example 4:**

```text
Input: "(()(()))"
Output: 6
```

### sol1:stack

Every position in the string has a _depth_ - some number of matching parentheses surrounding it. For example, the dot in `(()(.()))` has depth 2, because of these parentheses: `(__(.__))`

Our goal is to maintain the score at the current depth we are on. When we see an opening bracket, we increase our depth, and our score at the new depth is 0. When we see a closing bracket, we add twice the score of the previous deeper part - except when counting `()`, which has a score of 1.

```python
class Solution:
    def scoreOfParentheses(self, S: str) -> int:
        stack = [0]
        for s in S:
            if s == '(':
                stack.append(0)
            else:
                val = stack.pop()
                stack[-1] += max(1, 2 * val)
        return stack.pop()
```

### Sol2: Core

The key idea is that:

1. the balance tells you what "depth" you are at since with each '\(' we are increasing the depth by 1 \(kind of similar to the concept in Solution 1\).
2. the "cores" \(\) are the only structure that provides value, the outer parentheses just add some multiplier to the cores. So we only need to be concerned with those.

With those 2 ideas in mind, we are able to calculate how much the "core" is worth directly without having to calculate substructures recursively and then apply multipliers.

```python
def scoreOfParentheses(self, S: str) -> int:
        res = depth = 0
        for i, s in enumerate(S):
            if s == '(':
                depth += 1
            else:
                depth -= 1
                if S[i-1] == '(':
                    res += 2 ** depth
        return res
```

