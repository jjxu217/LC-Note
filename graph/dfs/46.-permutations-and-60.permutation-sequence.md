# 46/47 Permutations & 60.Permutation Sequence

## 46. Permutations

Given a collection of **distinct** integers, return all possible permutations.

**Example:**

```text
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

### Solution:

Permutation problem usually use use **Swap-Swap**  
Use **res.append\(nums\[:\]\)**, if nums is to be changed

```python
class Solution:
    def permute(self, nums):
        def dfs(idx = 0):
            # if all integers are used up
            if idx == n:  
                res.append(nums[:])
                return
            for i in range(idx, n):
                # place i-th integer first 
                # in the current permutation
                nums[idx], nums[i] = nums[i], nums[idx]
                # use next integers to complete the permutations
                dfs(idx + 1)
                # backtrack
                nums[idx], nums[i] = nums[i], nums[idx]
        
        n = len(nums)
        res = []
        dfs()
        return res

#iteration
    def permute(self, nums):
        ans = [[]]
        for n in nums:
            ans = [l[:i] + [n] + l[i:] for l in ans for i in range(len(l) + 1)]
        return ans
```

## 47. Permutations II

Given a collection of numbers that might contain duplicates, return all possible unique permutations.

**Example:**

```text
Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

### Solution:

1. Swap-swap: use set to handle duplication
2. Iteration: when find duplication, break
3. DFS: Use Counter to handle duplication

```python
class Solution:
    #swap-swap
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        n = len(nums)
        
        def dfs(idx):
            if idx == n:
                res.append(nums[:])
                return
            s = set()   #handle duplication
            for i in range(idx, n):
                if i == idx or nums[i] not in s:
                    nums[idx], nums[i] = nums[i], nums[idx]
                    dfs(idx + 1)
                    nums[idx], nums[i] = nums[i], nums[idx]
                    s.add(nums[i])
        
        dfs(0)
        return res
    
   #iteration 
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        ans = [[]]
        for n in nums:
            new_ans = []
            for l in ans:
                for i in range(len(l) + 1):
                    new_ans.append(l[:i] + [n] + l[i:])
                    if i < len(l) and n == l[i]: #handle duplication
                        break
            ans = new_ans
        return ans
    
    #use Counter
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        def dfs(path):
            if len(path) == len(nums):
                res.append(path[:])
                return
            for x in counter:
                if counter[x] > 0:
                    path.append(x)
                    counter[x] -= 1
                    dfs(path)
                    path.pop()
                    counter[x] += 1
                    
        res = []    
        counter = collections.Counter(nums)
        dfs([])
        return res
```

## 267. Palindrome Permutation II

Given a string `s`, return all the palindromic permutations \(without duplicates\) of it. Return an empty list if no palindromic permutation could be form.

**Example 1:**

```text
Input: "aabb"
Output: ["abba", "baab"]
```

**Example 2:**

```text
Input: "abc"
Output: []
```

```python
class Solution:
    def generatePalindromes(self, s: str) -> List[str]:
        def dfs(path):
            if len(path) == n:
                res.append(path)
                return
            for x in counter:
                if counter[x] > 0:
                    counter[x] -= 2
                    dfs(x + path + x)
                    counter[x] += 2
                    
        res = []    
        counter = collections.Counter(s)
        n = len(s)
        odd = [c for c, v in counter.items() if v % 2]
        if len(odd) > 1:
            return []
        elif len(odd) == 1:
            counter[odd[0]] -= 1
            dfs(odd[0])
        else:
            dfs('')
        return res
```

## 60. Permutation Sequence

The set `[1,2,3,...,`_`n`_`]` contains a total of _n_! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for _n_ = 3:

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

Given _n_ and _k_, return the _k_th permutation sequence.

**Note:**

* Given _n_ will be between 1 and 9 inclusive.
* Given _k_ will be between 1 and _n_! inclusive.

**Example 1:**

```text
Input: n = 3, k = 3
Output: "213"
```

**Example 2:**

```text
Input: n = 4, k = 9
Output: "2314"
```

### Solution:

For permutations of n, the first \(n-1\)! permutations start with 1, next \(n-1\)! ones start with 2, ... and so on. And in each group of \(n-1\)! permutations, the first \(n-2\)! permutations start with the smallest remaining number, ...

```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:  
        res, nums = '', [str(i) for i in range(1, n + 1)]
        k -= 1
        while n:
            n -= 1
            idx, k = divmod(k, math.factorial(n))
            res += nums.pop(idx)
        return res
        
 #back-track   
     def getPermutation(self, n, k):
        nums = [str(i) for i in range(1, n+1)]
        fact = [1] * n
        for i in range(1,n):
            fact[i] = i*fact[i-1]
        k -= 1
        ans = []
        for i in range(n, 0, -1):
            id, k = divmod(k, fact[i-1])
            ans.append(nums[id])
            nums.pop(id)
        return ''.join(ans)
```

