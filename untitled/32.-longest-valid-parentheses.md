# 32. Longest Valid Parentheses

Given a string containing just the characters `'('` and `')'`, find the length of the longest valid \(well-formed\) parentheses substring.

**Example 1:**

```text
Input: "(()"
Output: 2
Explanation: The longest valid parentheses substring is "()"
```

**Example 2:**

```text
Input: ")()())"
Output: 4
Explanation: The longest valid parentheses substring is "()()"
```

### Sol1: stack

从左到右扫描字符串，栈顶保存当前扫描的时候，合法序列前的一个位置位置下标是多少:

扫描到左括号，就将当前位置入栈。   
扫描到右括号，就将栈顶出栈（代表栈顶的左括号匹配到了右括号），然后分两种情况：

1. 栈不空，那么就用当前的位置减去栈顶的存的位置，然后就得到当前合法序列的长度，然后更新一下最长长度。
2. 栈是空的，说明之前没有与之匹配的左括号，那么就将当前的位置入栈。

```python
    def longestValidParentheses(self, s: str) -> int:
        stack = [-1]
        res = 0
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if len(stack) == 0:
                    stack.append(i)
                else:
                    res = max(res, i - stack[-1])
        return res
```

### Sol2: DP

```python
    # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i]
    def longestValidParentheses(self, s: str) -> int:  
        dp = [0] * (len(s))
        for i in range(1,len(s)):
            if s[i] == ')':
                # case 1: ()(), add nearest parentheses pairs + 2
                if s[i-1] == '(':
                    dp[i] = dp[i-2] + 2 if i >= 2 else 2
                # case 2: (()) 
                # i-dp[i-1]-1 is the index of last "(" not paired until this ")"
                elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':
                    # content within current matching pair is valid 
                    # add nearest parentheses pairs + 2 + parentheses before last "("
                    if i-dp[i-1]-2 > 0:
                        dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]
                    else:
                        dp[i] = dp[i-1] + 2
        return max(dp) if dp else 0
```

### Sol3: 正着扫+反着扫

从左到右扫描，用两个变量 left 和 right 保存的当前的左括号和右括号的个数，都初始化为 0 。

* 如果左括号个数等于右括号个数了，那么就更新合法序列的最长长度。
* 如果左括号个数大于右括号个数了，那么就接着向右边扫描。
* 如果左括号数目小于右括号个数了，那么后边无论是什么，此时都不可能是合法序列了，此时 left 和 right 归 0，然后接着扫描。

从左到右扫描完毕后，同样的方法从右到左再来一次，因为类似这样的情况 \( \( \( \) \) ，如果从左到右扫描到最后，left = 3，right = 2，期间不会出现 left == right。但是如果从右向左扫描，扫描到倒数第二个位置的时候，就会出现 left = 2，right = 2 ，就会得到一种合法序列。

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        res = 0
        l = r = 0
        for i in range(len(s)):
            if s[i] == '(':
                l += 1
            if s[i] == ')':
                r += 1
                if r == l:
                    res = max(res, 2 * r)
                elif r > l:
                    r = l = 0
        l = r = 0
        for i in range(len(s)-1, -1, -1):
            if s[i] == ')':
                r += 1
            if s[i] == '(':
                l += 1
                if r == l:
                    res = max(res, 2 * l)
                elif r < l:
                    r = l = 0                  
        return res   
```

