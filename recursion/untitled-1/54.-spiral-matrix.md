# 54. Spiral Matrix

Given a matrix of _m_ x _n_ elements \(_m_ rows, _n_ columns\), return all elements of the matrix in spiral order.

**Example 1:**

```text
Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

```text
Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        #layer by layer
        while matrix:
            res.extend(matrix.pop(0))
            if matrix and matrix[0]:
                res.extend(i.pop() for i in matrix)
            if matrix:
                res.extend(matrix.pop()[::-1])
            if matrix and matrix[0]:
                res.extend(i.pop(0) for i in matrix[::-1])
        return res
    
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        result = []
        while matrix:
            result.extend(matrix.pop(0))
            matrix = [*zip(*matrix)][::-1]    #rotate the remaining matrix counter-clockwise
        return result
```

## 59. Spiral Matrix II

Given a positive integer _n_, generate a square matrix filled with elements from 1 to _n_2 in spiral order.

**Example:**

```text
Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

![](../../.gitbook/assets/image%20%281%29.png)

### Solution1: print layer by layer

```python
#recursion
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        self.count = 1
        self.res = [[0] * n for _ in range(n)]
        
        def spiral(size, offset):
            
            if size == 1: 
                self.res[offset][offset] = self.count
                return 
            elif size == 0:
                return 
            for i in range(size - 1):
                self.res[offset][offset + i] = self.count
                self.count += 1
            for i in range(size - 1):
                self.res[offset + i][n - offset - 1] = self.count
                self.count += 1
            for i in range(size - 1):
                self.res[n - offset - 1][n - offset - 1 - i] = self.count
                self.count += 1
            for i in range(size - 1):
                self.res[n - offset - 1 - i][offset] = self.count
                self.count += 1
            spiral(size - 2, offset + 1)
        spiral(n, 0)  
        return self.res

#iteration
    def generateMatrix(self, n):
        if not n:
            return []
        res = [[0 for _ in range(n)] for _ in range(n)]
        left, right, top, down, num = 0, n-1, 0, n-1, 1
        while left <= right and top <= down:
            for i in range(left, right+1):
                res[top][i] = num 
                num += 1
            top += 1
            for i in range(top, down+1):
                res[i][right] = num
                num += 1
            right -= 1
            for i in range(right, left-1, -1):
                res[down][i] = num
                num += 1
            down -= 1
            for i in range(down, top-1, -1):
                res[i][left] = num
                num += 1
            left += 1
        return res
```

### Solution2: rotate

\(1\) Create a matrix to store the coordinates

> \(0,0\) \(0,1\) \(0,2\)

> \(1,0\) \(1,1\) \(1,2\)

> \(2,0\) \(2,1\) \(2,2\)

\(2\) Read it out using the trick of "[Spiral Matrix I](https://leetcode.com/discuss/46516/lines-recursive-python-solution-lines-solution-recursion)"

> \(0,0\) \(0,1\) \(0,2\) \(1,2\) \(2,2\) ...

\(3\) Put 1, 2, 3, ... n\*\*2 at these coordinates sequentially. Done.

```python
class Solution:
    def generateMatrix(self, n):   
        result = [[0] * n  for _ in range(n)]
        coord = [[(i,j) for j in range(n)] for i in range(n)]     
        count = 1

        while coord:
            for x, y in coord.pop(0):
                result[x][y] = count
                count += 1
            coord = [*zip(*coord)][::-1]

        return result
```

