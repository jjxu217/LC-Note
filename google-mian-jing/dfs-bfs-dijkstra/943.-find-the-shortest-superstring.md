# 943. Find the Shortest Superstring

Given an array A of strings, find any smallest string that contains each string in `A` as a substring.We may assume that no string in `A` is substring of another string in `A`. 

**Example 1:**

```text
Input: ["alex","loves","leetcode"]
Output: "alexlovesleetcode"
Explanation: All permutations of "alex","loves","leetcode" would also be accepted.
```

**Example 2:**

```text
Input: ["catg","ctaagt","gcta","ttca","atgcatc"]
Output: "gctaagttcatgcatc"
```

**Note:**

1. `1 <= A.length <= 12`
2. `1 <= A[i].length <= 20`

### **Ideaï¼šTSP, BFS + DP, time =** O\(n^2 \* 2^n\)

è¿™é“é¢˜å®é™…ä¸Šæ˜¯ä¸€ä¸ªå›¾çš„é—®é¢˜ã€‚  
å¯¹äº`A = ["catg","ctaagt","gcta","ttca","atgcatc"]`  
ä¸å¦¨è®¤ä¸ºæ¯ä¸€ä¸ªå­—ç¬¦ä¸²å¯¹åº”ä¸€ä¸ªç»“ç‚¹ã€‚è¾¹çš„æƒå€¼åˆ™å¯¹åº”ç€ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´é‡å¤éƒ¨åˆ†çš„é•¿åº¦ã€‚  
ï¼ˆ0å¯¹åº”â€™catgâ€™, 1å¯¹åº”â€™ctaagt,ä»¥æ­¤ç±»æ¨ï¼‰  
[![](https://buptwc.com/images/leetcode_943.png)](https://buptwc.com/images/leetcode_943.png)  
å…¶ä¸­ï¼Œ**`G[2][1] = 3`è¡¨ç¤º1ç»“ç‚¹è‹¥æ”¾åœ¨2ç»“ç‚¹åé¢å¯ä»¥çœä¸‹3ä¸ªå­—ç¬¦é•¿åº¦**ã€‚  
æœ€ç»ˆï¼Œçœå¾—è¶Šå¤šï¼Œæœ€åçš„å­—ç¬¦ä¸²é•¿åº¦å°±è¶ŠçŸ­ã€‚

é‚£ä¹ˆè¿™é“é¢˜å°±è½¬æ¢æˆäº†ï¼Œåœ¨ä¸€ä¸ªå›¾ä¸­ï¼Œä»æŸä¸ªç‚¹å‡ºå‘å°†æ‰€æœ‰ç‚¹æ°å¥½éå†ä¸€éï¼Œä½¿å¾—æœ€åè·¯è¿‡çš„è·¯å¾„é•¿åº¦æœ€é•¿ã€‚ï¼ˆæ³¨æ„ï¼Œè™½ç„¶1,3ä¹‹é—´æ²¡æœ‰è¿çº¿ä½†ä»ç„¶å¯ä»¥ä»ç»“ç‚¹1èµ°åˆ°ç»“ç‚¹3ã€‚ï¼‰

é¦–å…ˆæˆ‘ä»¬å°†å›¾æ„é€ å‡ºæ¥

```python
def getDistance(s1, s2):
        for i in range(1, len(s1)):
            if s2.startswith(s1[i:]):
                return len(s1) - i
        return 0

n = len(A)
G = [[0]*n for _ in range(n)]
for i in range(n):
    for j in range(i+1, n):
        G[i][j] = getDistance(A[i], A[j])
        G[j][i] = getDistance(A[j], A[i])
```

æˆ‘ä»¬è¿™é‡Œé‡‡ç”¨bfsçš„æ–¹æ³•å»éå†æ•´ä¸ªå›¾ï¼Œä½†å¦‚æœä¸åšä»»ä½•å¤„ç†ï¼Œå°†æ‰€æœ‰æƒ…å†µå…¨éƒ¨è€ƒè™‘çš„è¯ï¼Œå…±æœ‰`12x11x10x...x1 = 12!`ç§æƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦è¿‡å¤§ã€‚  
ç¨å¾®æƒ³ä¸€æƒ³ï¼Œè¿™å…¶ä¸­æœ‰å¾ˆå¤šé‡å¤è®¡ç®—ï¼Œä¾‹å¦‚å¯¹äºè¿™ä¸¤ä¸ªçŠ¶æ€ï¼š

1. 2-&gt;1-&gt;3-&gt;â€¦
2. 1-&gt;2-&gt;3-&gt;â€¦ åŒæ ·æ˜¯éå†äº†1,2,3è¿™ä¸‰ä¸ªç»“ç‚¹ï¼Œå¹¶ä¸”å½“å‰éƒ½å¤„åœ¨3ç»“ç‚¹ä¸Šï¼Œæˆ‘ä»¬æ˜¯å¹¶ä¸ç”¨å°†è¿™ä¸¤ç§æƒ…å†µéƒ½è®¡ç®—çš„ã€‚ å‡è®¾å¯¹äº`1->2->3`æˆ‘ä»¬è®¡ç®—å‡ºæ¥å·²ç»èµ°è¿‡çš„é•¿åº¦ä¸º`L1`ï¼Œå¯¹äº`2->1->3`æˆ‘ä»¬è®¡ç®—å‡ºæ¥å·²ç»èµ°è¿‡çš„é•¿åº¦ä¸º`L2`ï¼Œå¦‚æœæœ‰`L2 < L1`ï¼Œé‚£ä¹ˆæ— è®ºåé¢æ€ä¹ˆèµ°ï¼Œç¬¬äºŒç§æƒ…å†µéƒ½ä¸å¯èƒ½æ¯”ç¬¬ä¸€ç§æƒ…å†µæ›´ä¼˜ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥èˆå¼ƒæ‰ç¬¬äºŒç§æƒ…å†µã€‚

åŸºäºè¿™ä¸ªæ€æƒ³ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç©ºé—´`d[mask][node]`æ¥è®°å½•å½“å‰çŠ¶æ€ä¸‹å·²ç»èµ°çš„è·¯ç¨‹ã€‚å…¶ä¸­ï¼š  
`mask`è¡¨ç¤ºå½“å‰å·²ç»éå†è¿‡çš„ç»“ç‚¹ï¼Œ`10011`è¡¨ç¤ºå·²ç»éå†äº†`0,1,4`ä¸‰ä¸ªç»“ç‚¹ã€‚ï¼ˆ1 &lt;&lt; iï¼‰  
`node`è¡¨ç¤ºå½“å‰æ‰€å¤„ç»“ç‚¹ã€‚

åœ¨bfsä¸­ï¼Œè¿™é‡Œé‡‡ç”¨äº†è¿™æ ·çš„ç»“æ„`(`**`node, mask, path, repeat_len`**`)`ã€‚å…¶ä¸­ï¼š  
`node`è¡¨ç¤ºå½“å‰ç»“ç‚¹  
`mask`è¡¨ç¤ºå½“å‰éå†è¿‡çš„ç»“ç‚¹  
`path`è¡¨ç¤ºéå†ç»“ç‚¹çš„é¡ºåº\(é•¿åº¦ä¸è¶…è¿‡12ï¼Œæ‰€ä»¥ä¸ç”¨æ‹…å¿ƒç©ºé—´è¿‡å¤§\)  
`repeat_len`è¡¨ç¤ºç›®å‰é‡å¤éƒ¨åˆ†çš„é•¿åº¦ã€‚

å½“`mask == 11111`æ—¶ï¼Œè¡¨ç¤ºå·²ç»éå†è¿‡æ‰€æœ‰ç»“ç‚¹ï¼Œæˆ‘ä»¬å–æ­¤æ—¶`repeat_len`æœ€å¤§çš„pathï¼Œç„¶åé€šè¿‡pathæ„é€ æœ€åçš„å­—ç¬¦ä¸²

ä¾‹å¦‚`path = [2,1,3,0,4]`ï¼Œé‚£ä¹ˆæ„é€ å‡½æ•°å¦‚ä¸‹ï¼š

```python
def pathtoStr(A, G, path):
    res = A[path[0]]
    for i in range(1, len(path)):
        indice = G[path[i-1]][path[i]]
        res += A[path[i]][indice:]
    return res
```

å…¨éƒ¨ä»£ç å¦‚ä¸‹ï¼š

```python
class Solution(object):
    def shortestSuperstring(self, A):
        def getDistance(s1, s2):
            for i in range(1, len(s1)):
                if s2.startswith(s1[i:]):
                    return len(s1) - i
            return 0

        def pathtoStr(A, G, path):
            res = A[path[0]]
            for i in range(1, len(path)):
                res += A[path[i]][G[path[i-1]][path[i]]:]
            return res

        #build the graph
        n = len(A)
        G = [[0]*n for _ in range(n)]
        for i in range(n):
            for j in range(i+1, n):
                G[i][j] = getDistance(A[i], A[j])
                G[j][i] = getDistance(A[j], A[i])

        d = [[0]*n for _ in range(1<<n)]
        Q = collections.deque([(i, 1<<i, [i], 0) for i in range(n)])
        l = -1 # è®°å½•æœ€å¤§çš„repeat_len
        P = [] # è®°å½•å¯¹åº”çš„path
        while Q:
            node, mask, path, dis = Q.popleft()
            if dis < d[mask][node]: continue #pruning
            if mask == (1<<n) - 1 and dis > l:
                P,l = path,dis
                continue
            for i in range(n):
                nxt_mask = mask | (1<<i)
                # case1: ä¸èƒ½èµ°å›å¤´è·¯ï¼Œå› ä¸ºæ¯ä¸ªç»“ç‚¹åªèƒ½éå†ä¸€æ¬¡
                # case2: å¦‚æœèµ°å½“å‰è¿™æ¡è·¯èƒ½å¤Ÿè·å¾—æ›´å¤§çš„é‡å¤é•¿åº¦ï¼Œæ‰ç»§ç»­è€ƒè™‘
                if nxt_mask != mask and d[mask][node] + G[node][i] >= d[nxt_mask][i]:
                    d[nxt_mask][i] = d[mask][node] + G[node][i]
                    Q.append((i, nxt_mask, path+[i], d[nxt_mask][i]))

        return pathtoStr(A,G,P)
```

There are `ğ‘›` possible start vertices and `2^ğ‘›` possible subgraphs. So this function will be called on at most `ğ‘›â‹…2^ğ‘›` distinct arguments \(the target never changes\). Each call performs at most ğ‘‚\(ğ‘›\) work \(there are at most ğ‘› neighbors\). Hence the total work you're doing is `ğ‘‚(ğ‘›^2 * 2 ^ ğ‘›)`.

